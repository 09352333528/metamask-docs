"use strict";(self.webpackChunkmetamask_docs=self.webpackChunkmetamask_docs||[]).push([[9635],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(67294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var p=a.createContext({}),l=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return a.createElement(p.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=l(t),h=s,m=u["".concat(p,".").concat(h)]||u[h]||d[h]||r;return t?a.createElement(m,i(i({ref:n},c),{},{components:t})):a.createElement(m,i({ref:n},c))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,i=new Array(r);i[0]=h;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[u]="string"==typeof e?e:s,i[1]=o;for(var l=2;l<r;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},47708:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var a=t(87462),s=(t(67294),t(3905));const r={description:"Learn how to integrate custom EVM accounts in MetaMask"},i="Integrate custom EVM accounts in MetaMask",o={unversionedId:"how-to/integrate-custom-evm-accounts",id:"how-to/integrate-custom-evm-accounts",title:"Integrate custom EVM accounts in MetaMask",description:"Learn how to integrate custom EVM accounts in MetaMask",source:"@site/snaps/how-to/integrate-custom-evm-accounts.md",sourceDirName:"how-to",slug:"/how-to/integrate-custom-evm-accounts",permalink:"/zs/keyring-doc/snaps/how-to/integrate-custom-evm-accounts",draft:!1,editUrl:"https://github.com/MetaMask/metamask-docs/edit/main/snaps/how-to/integrate-custom-evm-accounts.md",tags:[],version:"current",frontMatter:{description:"Learn how to integrate custom EVM accounts in MetaMask"},sidebar:"snapsSidebar",previous:{title:"Troubleshoot",permalink:"/zs/keyring-doc/snaps/how-to/troubleshoot"},next:{title:"Concepts",permalink:"/zs/keyring-doc/snaps/category/concepts"}},p={},l=[{value:"Implementing a <code>Keyring</code> class",id:"implementing-a-keyring-class",level:2},{value:"Snap account creation flow",id:"snap-account-creation-flow",level:3},{value:"Synchronous signing flow",id:"synchronous-signing-flow",level:3},{value:"Asynchronous signing flow",id:"asynchronous-signing-flow",level:3},{value:"Exposing the <code>Keyring</code> class as JSON-RPC endpoints",id:"exposing-the-keyring-class-as-json-rpc-endpoints",level:2},{value:"Using the keyring API from a Dapp",id:"using-the-keyring-api-from-a-dapp",level:2}],c={toc:l},u="wrapper";function d(e){let{components:n,...r}=e;return(0,s.kt)(u,(0,a.Z)({},c,r,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"integrate-custom-evm-accounts-in-metamask"},"Integrate custom EVM accounts in MetaMask"),(0,s.kt)("p",null,"Using the ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/concepts/keyring-api"},"Snaps Keyring API"),", you can integrate custom EVM accounts directly in MetaMask. These accounts will be displayed alongside MetaMask-controlled accounts in the UI:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Deep UI integration for custom EVM accounts",src:t(17196).Z,width:"712",height:"1198"})),(0,s.kt)("p",null,"Creating a keyring snap allows Dapps to connect to its accounts and submit requests like ",(0,s.kt)("inlineCode",{parentName:"p"},"personal_sign"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"eth_sendTransaction"),", etc. as if these were regular, MetaMask-controlled accounts."),(0,s.kt)("h2",{id:"implementing-a-keyring-class"},"Implementing a ",(0,s.kt)("inlineCode",{parentName:"h2"},"Keyring")," class"),(0,s.kt)("p",null,"The first step for creating a Keyring snap is to implement the ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/modules#keyring"},(0,s.kt)("inlineCode",{parentName:"a"},"Keyring")," interface"),". This interface describes all the methods necessary to make your custom EVM accounts work inside MetaMask with your own logic. The next sections will go over the methods of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Keyring")," interface by describing the different flows that it handles."),(0,s.kt)("h3",{id:"snap-account-creation-flow"},"Snap account creation flow"),(0,s.kt)("p",null,'The first interaction between users and your Keyring snap will be the snap account creation process. The MetaMask account selection modal has an option called "Add snap account":'),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"add snap account option",src:t(19848).Z,width:"682",height:"1058"})),(0,s.kt)("p",null,"This option will show a list of keyring snaps, but will ultimately redirect the user to the companion Dapp for your Keyring snap. That is, a Dapp that contains all the UI to configure and manage the Keyring snap."),(0,s.kt)("p",null,"On that Dapp, you'll present a custom user interface allowing the user configure their custom EVM account. The Dapp will make use of the ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/classes/KeyringSnapRpcClient#createaccount"},(0,s.kt)("inlineCode",{parentName:"a"},"KeyringSnapRpcClient"),"'s ",(0,s.kt)("inlineCode",{parentName:"a"},"createAccount")," method"),", which will call your ",(0,s.kt)("inlineCode",{parentName:"p"},"Keyring")," class' method of the same name. An example of this can be found in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/MetaMask/snap-simple-keyring/blob/d3f7f0156c59059c995fea87f90a3d0ad3a4c135/packages/site/src/pages/index.tsx#L136"},"Simple keyring snap companion Dapp"),"."),(0,s.kt)("p",null,"In your ",(0,s.kt)("inlineCode",{parentName:"p"},"Keyring")," class' ",(0,s.kt)("inlineCode",{parentName:"p"},"createAccount")," method, your responsibility is to create the account based on the parameters that were passed to you. Your snap has to keep track of the accounts that it creates, which can be done using ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/rpc-api#snap_managestate"},(0,s.kt)("inlineCode",{parentName:"a"},"snap_manageState")),". Once your snap has created an account, it should notify MetaMask using the ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/rpc-api#createaccount"},(0,s.kt)("inlineCode",{parentName:"a"},"snap_manageAccounts")," ",(0,s.kt)("inlineCode",{parentName:"a"},"createAccount")," method"),". An example of this process can be found in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/MetaMask/snap-simple-keyring/blob/d3f7f0156c59059c995fea87f90a3d0ad3a4c135/packages/snap/src/keyring.ts#L61"},"Simple keyring snap code"),"."),(0,s.kt)("p",null,"Once your snap has created an account, that account can be used to sign messages and transactions. In the following sections we'll look at how this can be done."),(0,s.kt)("h3",{id:"synchronous-signing-flow"},"Synchronous signing flow"),(0,s.kt)("p",null,"Your Keyring snap will implement the simple flow if it's able to sign transactions directly. This would be the case if the snap doesn't need a third-party such as a hardware key or a second account's signature, as would be the case for a threshold signature scheme. The flow would look like this:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Simple keyring snap flow",src:t(19698).Z,width:"2044",height:"1260"})),(0,s.kt)("p",null,"For a full example of a simple keyring snap, see ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/MetaMask/snap-simple-keyring"},(0,s.kt)("inlineCode",{parentName:"a"},"snap-simple-keyring")," on GitHub"),"."),(0,s.kt)("p",null,"The flow starts when a Dapp calls a method such as ",(0,s.kt)("inlineCode",{parentName:"p"},"personal_sign")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"eth_signTransaction"),", or when the user initiates a new funds transfer from the MetaMask UI. At that point, MetaMask will detect that this interaction is requested for an account controlled by your Keyring snap."),(0,s.kt)("p",null,"After the user approves the transaction in the UI, MetaMask will call the ",(0,s.kt)("inlineCode",{parentName:"p"},"submitRequest")," method of your ",(0,s.kt)("inlineCode",{parentName:"p"},"Keyring")," class. ",(0,s.kt)("inlineCode",{parentName:"p"},"submitRequest")," will receive the original RPC request, and will need to return a ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/modules#submitrequestresponsestruct"},(0,s.kt)("inlineCode",{parentName:"a"},"SubmitRequestResponse"))," with ",(0,s.kt)("inlineCode",{parentName:"p"},"pending")," set to ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"result")," set to the requested signature."),(0,s.kt)("admonition",{type:"caution"},(0,s.kt)("p",{parentName:"admonition"},"If your Keyring snap receives an ",(0,s.kt)("inlineCode",{parentName:"p"},"eth_sendTransaction")," request, you must treat it like an ",(0,s.kt)("inlineCode",{parentName:"p"},"eth_signTransaction")," request. That is, your snap is responsible for providing the signature in the response, and MetaMask is responsible for broadcasting the transaction.")),(0,s.kt)("h3",{id:"asynchronous-signing-flow"},"Asynchronous signing flow"),(0,s.kt)("p",null,"If your keyring snap implements a more complex scheme, e.g. threshold signing, then the flow will be more involved, and more ",(0,s.kt)("inlineCode",{parentName:"p"},"Keyring")," methods will be used. The diagram below will help you visualize the flow:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Keyring snap complex flow",src:t(85121).Z,width:"1822",height:"1512"})),(0,s.kt)("p",null,"The flow starts the same way: a request to sign a transaction or arbitrary data is initiated by a Dapp or by the user. After approval, your snap's ",(0,s.kt)("inlineCode",{parentName:"p"},"submitRequest")," method is called. "),(0,s.kt)("p",null,"Since your snap won't answer the request directly, it should store the pending request in its internal state using ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/rpc-api#snap_managestate"},(0,s.kt)("inlineCode",{parentName:"a"},"snap_manageState")),". This list of pending requests should be returned when the ",(0,s.kt)("inlineCode",{parentName:"p"},"listRequests")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"getRequest")," methods of your ",(0,s.kt)("inlineCode",{parentName:"p"},"Keyring")," class are called."),(0,s.kt)("p",null,'After storing the pending request, your snap should direct the user to a "companion Dapp" \u2013 a Dapp that serves as UI for the snap \u2013 where the rest of the flow can continue. Your snap can do this by creating a pop-up using ',(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/rpc-api#snap_dialog"},(0,s.kt)("inlineCode",{parentName:"a"},"snap_dialog"))," instructing the user to go to the companion Dapp's URL."),(0,s.kt)("p",null,"The Dapp will list your snap's pending requests using an RPC call facilitated by the ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/classes/KeyringSnapRpcClient#listrequests"},(0,s.kt)("inlineCode",{parentName:"a"},"KeyringSnapRpcClient"),"'s ",(0,s.kt)("inlineCode",{parentName:"a"},"listRequests")," method"),". The user can then act on those requests using whatever process applies to the snap."),(0,s.kt)("p",null,"Once the signing process is completed, the companion Dapp will resolve the request using the ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/classes/KeyringSnapRpcClient#approverequest"},(0,s.kt)("inlineCode",{parentName:"a"},"KeyringSnapRpcClient"),"'s ",(0,s.kt)("inlineCode",{parentName:"a"},"approveRequest")," method"),", which will call the snap's ",(0,s.kt)("inlineCode",{parentName:"p"},"Keyring")," method of the same name. This method receives the request's ID, as well as the final result."),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"approveRequest")," gets called, it can resolve the pending request by using the ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/rpc-api#submitresponse"},(0,s.kt)("inlineCode",{parentName:"a"},"snap_manageAccounts"),"' ",(0,s.kt)("inlineCode",{parentName:"a"},"submitResponse")," method"),"."),(0,s.kt)("h2",{id:"exposing-the-keyring-class-as-json-rpc-endpoints"},"Exposing the ",(0,s.kt)("inlineCode",{parentName:"h2"},"Keyring")," class as JSON-RPC endpoints"),(0,s.kt)("p",null,"Once you've written all the business logic for your custom EVM account type, the next step is to expose it as a JSON-RPC API. Exposing a JSON-RPC API in Snaps is done by ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/exports#onrpcrequest"},"exporting an ",(0,s.kt)("inlineCode",{parentName:"a"},"onRpcRequest")," function")," from the snap package."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"@metamask/keyring-api")," package provides a helper called ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/modules#handlekeyringrequest"},(0,s.kt)("inlineCode",{parentName:"a"},"handleKeyringRequest")),". This helper takes an instance of your ",(0,s.kt)("inlineCode",{parentName:"p"},"Keyring")," class and a request object. It responds to requests where the ",(0,s.kt)("inlineCode",{parentName:"p"},"method")," is of type ",(0,s.kt)("inlineCode",{parentName:"p"},"keyring_*"),", and throws a ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/classes/MethodNotSupportedError"},(0,s.kt)("inlineCode",{parentName:"a"},"MethodNotSupportedError"))," if it doesn't recognize the request method."),(0,s.kt)("p",null,"Since your snap will most likely want to answer other JSON-RPC requests than the ",(0,s.kt)("inlineCode",{parentName:"p"},"keyring_*")," ones, another helper called ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/modules#buildhandlerschain"},(0,s.kt)("inlineCode",{parentName:"a"},"buildHandlersChain"))," lets you chain multiple RPC handlers together. As each handler in the chain throws a ",(0,s.kt)("a",{parentName:"p",href:"/zs/keyring-doc/snaps/reference/keyring-api/classes/MethodNotSupportedError"},(0,s.kt)("inlineCode",{parentName:"a"},"MethodNotSupportedError")),", the next handler in the chain will be called. The return value of ",(0,s.kt)("inlineCode",{parentName:"p"},"buildHandlersChain")," is a function that can be used as the ",(0,s.kt)("inlineCode",{parentName:"p"},"onRpcRequest")," export."),(0,s.kt)("p",null,"Here's an example of composing two handlers: the keyring handler and a custom handler. This code would go in ",(0,s.kt)("inlineCode",{parentName:"p"},"packages/snap/src/index.ts"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  MethodNotSupportedError,\n  buildHandlersChain,\n  handleKeyringRequest,\n} from '@metamask/keyring-api';\nimport type { OnRpcRequestHandler } from '@metamask/snaps-types';\n\n// This is your custom EVM account implementation\nimport { MyKeyring } from './keyring';\n\nlet keyring: MyKeyring;\n\n/**\n * Handle keyring requests.\n *\n * @param args - Request arguments.\n * @param args.request - Request to execute.\n * @returns The execution result.\n */\nconst keyringHandler: OnRpcRequestHandler = async ({ request }) => {\n  if (!keyring) {\n    const state = await snap.request({\n      method: 'snap_manageState',\n      params: { operation: 'get' },\n    });\n    if (!keyring) {\n      keyring = new MyKeyring(state);\n    }\n  }\n  return await handleKeyringRequest(keyring, request);\n};\n\n/**\n * Execute a custom snap request.\n *\n * @param args - Request arguments.\n * @param args.request - Request to execute.\n * @returns The execution result.\n */\nconst customHandler: OnRpcRequestHandler = async ({\n  request,\n}): Promise<any> => {\n  switch (request.method) {\n    // internal methods\n    case 'mysnap_hello': {\n      return 'Hello World!';\n    }\n\n    default: {\n      throw new MethodNotSupportedError(request.method);\n    }\n  }\n};\n\n/**\n * Compose both handlers\n */\nexport const onRpcRequest: OnRpcRequestHandler = buildHandlersChain(\n  keyringHandler,\n  customHandler,\n);\n")),(0,s.kt)("h2",{id:"using-the-keyring-api-from-a-dapp"},"Using the keyring API from a Dapp"),(0,s.kt)("p",null,"TODO"))}d.isMDXComponent=!0},19848:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/add-snap-account-a0b0b4854e79cd62fa300b40e9e2f9ca.png"},17196:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/keyring-accounts-ui-f345af5d51513180efda9ccce62d9001.png"},85121:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/keyring-snap-complex-flow-b1f803e0e7329c394f17910c67b9350d.png"},19698:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/keyring-snap-simple-flow-86d162f98ddac87d1fcfd21fed2d161d.png"}}]);