"use strict";(self.webpackChunkmetamask_docs=self.webpackChunkmetamask_docs||[]).push([[1507],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=l(n),d=s,m=u["".concat(p,".").concat(d)]||u[d]||h[d]||r;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[u]="string"==typeof e?e:s,i[1]=o;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},86454:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var a=n(87462),s=(n(67294),n(3905));const r={},i="Working with third-party snaps",o={unversionedId:"how-to/work-with-existing-snaps",id:"how-to/work-with-existing-snaps",title:"Working with third-party snaps",description:"Some snaps are designed to communicate with Dapps. If you are a Dapp developer, you can use these snaps to take advantage of new features enabled by snaps. This is possible because snaps can expose an RPC API. Snaps can decide to make their API available to Dapps by requesting the endowment:rpc permission.",source:"@site/snaps/how-to/work-with-existing-snaps.md",sourceDirName:"how-to",slug:"/how-to/work-with-existing-snaps",permalink:"/zs/working-with-snaps/snaps/how-to/work-with-existing-snaps",draft:!1,editUrl:"https://github.com/MetaMask/metamask-docs/edit/main/snaps/how-to/work-with-existing-snaps.md",tags:[],version:"current",frontMatter:{},sidebar:"snapsSidebar",previous:{title:"Troubleshoot",permalink:"/zs/working-with-snaps/snaps/how-to/troubleshoot"},next:{title:"Concepts",permalink:"/zs/working-with-snaps/snaps/concepts"}},p={},l=[{value:"Connecting to a snap",id:"connecting-to-a-snap",level:2},{value:"User rejects the install request",id:"user-rejects-the-install-request",level:3},{value:"User approves the install request",id:"user-approves-the-install-request",level:3},{value:"Snap is already installed",id:"snap-is-already-installed",level:3},{value:"Finding out whether a snap is installed",id:"finding-out-whether-a-snap-is-installed",level:2},{value:"Reconnecting to a snap",id:"reconnecting-to-a-snap",level:2}],c={toc:l},u="wrapper";function h(e){let{components:t,...n}=e;return(0,s.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"working-with-third-party-snaps"},"Working with third-party snaps"),(0,s.kt)("p",null,"Some snaps are designed to communicate with Dapps. If you are a Dapp developer, you can use these snaps to take advantage of new features enabled by snaps. This is possible because ",(0,s.kt)("a",{parentName:"p",href:"/zs/working-with-snaps/snaps/reference/exports#onrpcrequest"},"snaps can expose an RPC API"),". Snaps can decide to make their API available to Dapps by requesting the ",(0,s.kt)("a",{parentName:"p",href:"/zs/working-with-snaps/snaps/reference/permissions#endowmentrpc"},(0,s.kt)("inlineCode",{parentName:"a"},"endowment:rpc"))," permission."),(0,s.kt)("h2",{id:"connecting-to-a-snap"},"Connecting to a snap"),(0,s.kt)("p",null,"Connecting to a snap is done by using the ",(0,s.kt)("a",{parentName:"p",href:"/zs/working-with-snaps/snaps/reference/rpc-api#wallet_requestsnaps"},(0,s.kt)("inlineCode",{parentName:"a"},"wallet_requestSnaps"))," method from your Dapp. If a user does not have a snap installed in their MetaMask, MetaMask will prompt the user to install the snap. There are different possible outcomes from calling ",(0,s.kt)("inlineCode",{parentName:"p"},"wallet_requestSnaps"),":"),(0,s.kt)("h3",{id:"user-rejects-the-install-request"},"User rejects the install request"),(0,s.kt)("p",null,"If the user rejects the install request, the call to ",(0,s.kt)("inlineCode",{parentName:"p"},"wallet_requestSnaps")," will throw with:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{ code: 4001, message: "User rejected the request." Z}\n')),(0,s.kt)("h3",{id:"user-approves-the-install-request"},"User approves the install request"),(0,s.kt)("p",null,"If the user approves the install request, the call to ",(0,s.kt)("inlineCode",{parentName:"p"},"wallet_requestSnaps")," will return an object with the following shape:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "SNAP_ID": {\n        "blocked": false,\n        "enabled": true,\n        "id": "SNAP_ID",\n        "initialPermissions": {\n            // ...all the permissions in the snap\'s manifest\n        },\n        "version": "SNAP_VERSION"\n    }\n}\n')),(0,s.kt)("h3",{id:"snap-is-already-installed"},"Snap is already installed"),(0,s.kt)("p",null,"If the snap was already installed, the call to ",(0,s.kt)("inlineCode",{parentName:"p"},"wallet_requestSnaps")," will return the same object as for a fresh install of the snap, with the difference that the user won't see a confirmation pop-up asking them to install the snap."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"Snaps are installed into the MetaMask instance of each user. If a snap stores data, that data is specific to that user's instance of MetaMask. However, that data can be shared with multiple dapps. Do not assume that data stored by a snap is unique to your dapp. ")),(0,s.kt)("h2",{id:"finding-out-whether-a-snap-is-installed"},"Finding out whether a snap is installed"),(0,s.kt)("p",null,"Finding out whether a snap is installed is done using the ",(0,s.kt)("a",{parentName:"p",href:"/zs/working-with-snaps/snaps/reference/rpc-api#wallet_getsnaps"},(0,s.kt)("inlineCode",{parentName:"a"},"wallet_getSnaps"))," method from your Dapp. You'll receive a list of ",(0,s.kt)("em",{parentName:"p"},"only")," those snaps that are connected to your current Dapp."),(0,s.kt)("p",null,"The response comes in the form of an object keyed by the ID of the snap. Each value is a nested object with additional information like the version of the snap that is installed."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("inlineCode",{parentName:"p"},"wallet_getSnaps")," only returns the snaps that are connected to your dapp. The user may have other snaps installed that your dapp is not aware of. ")),(0,s.kt)("p",null,"A sample code you can use to verify whether the snap with e.g. ID ",(0,s.kt)("inlineCode",{parentName:"p"},"npm:super-snap")," is installed would be:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const snaps = await ethereum.request({\n  method: 'wallet_getSnaps'\n});\n\nconst isMySnapInstalled = Object.keys(snaps).includes('npm:super-snap');\n")),(0,s.kt)("p",null,"If you need to work with a specific version of a snap, you can instead iterate over ",(0,s.kt)("inlineCode",{parentName:"p"},"Object.values(snaps)"),", and use the ",(0,s.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"version")," properties inside each object to figure out whether the snap is installed with the required version."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"It is not possible for a user to install multiple versions of a snap into the same instance of MetaMask. You should avoid requiring a specific version of a snap unless you absolutely need to. In most cases, you should request the latest version of the snap and architect your Dapp to be able to work with that version. ")),(0,s.kt)("h2",{id:"reconnecting-to-a-snap"},"Reconnecting to a snap"),(0,s.kt)("p",null,"At any time, a user can open their MetaMask Snaps settings menu and see all of the dapps that are connected to a snap. From that menu they can revoke a dapp connection. If your dapp loses the connection to a snap, you can reconnect with ",(0,s.kt)("inlineCode",{parentName:"p"},"wallet_requestSnaps"),". Since the snap is already installed, you will get a success response without MetaMask showing a popup. However, if the user has disabled the snap, the response will have ",(0,s.kt)("inlineCode",{parentName:"p"},"enabled")," set to ",(0,s.kt)("inlineCode",{parentName:"p"},"false")," for your SNAP_ID:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "SNAP_ID": {\n        "blocked": false,\n        "enabled": false,\n        "id": "SNAP_ID",\n        "initialPermissions": {\n            // ...all the permissions in the snap\'s manifest\n        },\n        "version": "SNAP_VERSION"\n    }\n}\n')))}h.isMDXComponent=!0}}]);